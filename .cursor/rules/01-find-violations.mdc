---
description: 
globs: 
alwaysApply: false
---
You are an AI assistant tasked with helping a developer identify and plan refactoring for legacy component usage. Follow these instructions carefully to complete the task in two main steps.

First, I will provide you with the following information:
<directory>{{DIRECTORY}}</directory>

Step 1: Find violations

1. Run a scan using the report-all-violations function with the following parameters:
   - directory: {{DIRECTORY}}
   - groupBy: "folder"
   
   Store the result in a variable called scanResult.

2. Deduplicate violations by file and line:
   - Process scanResult to remove duplicate entries that have the same file path and line number
   - When combining duplicates, merge the component/class information (e.g., "btn, btn-primary violations on line 10")
   - Keep the deduplicated count for accurate violation totals
   - Store the deduplicated result and use it for all subsequent processing

3. Perform first-level error handling:
   - If the function call returns an error, respond with:
     <commentary>üö® *Tool execution failed* ‚Äì [error message]</commentary>
     Then stop execution.
   - If no violations are found, respond with:
     "‚úÖ No legacy usage found."
     Then stop execution.
   - Otherwise, continue to the next step.

4. Output the results for the user:
   - Print the ranked list of folders inside <folders> tags, like this:
     <folders>
     1. [path/to/folder-A] ‚Äì [X] violations in [Y] files
     2. [path/to/folder-B] ‚Äì [X] violations in [Y] files
     ...
     </folders>
   - After the </folders> tag, ask exactly once:
     *Which sub-folder should I scan?*
     (Accept either full path or list index.)

Do not output anything else outside the <folders> tags and the follow-up question, unless you need to show a <commentary> block for error or clarification.

Step 2: Target sub-folder scan

Once the user provides a subfolder choice, proceed as follows:

1. Validate the user input:
   - If the chosen subfolder is not in rankedFolders, respond with:
     <commentary>‚ùå *Selected sub-folder not found in previous list. Please choose a valid entry.*</commentary>
     Then stop execution.

2. Run a file-level scan:
   - Use the report-all-violations function with these parameters:
     - directory: {{SUBFOLDER}}
     - groupBy: "file"
   - Store the result in a variable called fileScan.

3. Deduplicate violations by file and line:
   - Process fileScan to remove duplicate entries that have the same file path and line number
   - When combining duplicates, merge the component/class information
   - Keep the deduplicated count for accurate violation totals
   - Store the deduplicated result and use it for all subsequent processing

4. Perform error handling and validation:
   - If the function call returns an error, respond with:
     <commentary>üö® *Tool execution failed* ‚Äì [error message]</commentary>
     Then stop execution.
   - If fileScan.rows.length is 0, respond with:
     <commentary>‚ö†Ô∏è No violations found in {{SUBFOLDER}}.</commentary>
     Then stop execution.
   - Sort the files by number of violations (descending) and then alphabetically.

5. Output the results for the plan phase:
   - Print the sorted list of files inside <violations> tags, like this:
     <violations>
     1. [path/to/file-A.tsx] ‚Äì [X] violations
     2. [path/to/file-B.tsx] ‚Äì [X] violations
     ...
     </violations>
   - After the </violations> tag, prompt the user with:
     ‚ùì **Please attach the "Plan Phase" rules now so I can start refactoring planning.**